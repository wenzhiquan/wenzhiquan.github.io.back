<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温智全的博客</title>
  
  <subtitle>Wenknows&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenzhiquan.github.io/"/>
  <updated>2020-05-15T04:00:00.000Z</updated>
  <id>http://wenzhiquan.github.io/</id>
  
  <author>
    <name>温智全</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>非暴力沟通</title>
    <link href="http://wenzhiquan.github.io/2020/05/15/2020-05-15-non-violence-communicate/"/>
    <id>http://wenzhiquan.github.io/2020/05/15/2020-05-15-non-violence-communicate/</id>
    <published>2020-05-15T04:00:00.000Z</published>
    <updated>2020-05-15T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本周阅读了《非暴力沟通》了解到我们周围其实充满了无意识的“暴力沟通”，比如直言“你这个方案不对”，“你应该这么这么做”等等，这种沟通很可能导致对方有很不好的感受，不利于后续的沟通。所以在沟通之前我们可以先把谈话目标说出来，然后采用四步法进行沟通：讲事实，讲感受，讲原因，讲需
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于我们的上下文切换</title>
    <link href="http://wenzhiquan.github.io/2020/05/09/2020-05-09-context-switch/"/>
    <id>http://wenzhiquan.github.io/2020/05/09/2020-05-09-context-switch/</id>
    <published>2020-05-09T04:00:00.000Z</published>
    <updated>2020-05-09T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;就像电脑的CPU一样，我们做事时，其实也是有上下文的，如果不断被其他事情打断，那我们切换回原来上下文的成本就会非常高，会极大的降低我们的工作效率，所以集中精力免打扰的完整的做完一件事情才能最大限度的利用好我们的精力和能力。应用在我们工作中，一天中可以在某几段需要集中的整块时
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>立即行动</title>
    <link href="http://wenzhiquan.github.io/2020/04/26/2020-04-26-act-immediately/"/>
    <id>http://wenzhiquan.github.io/2020/04/26/2020-04-26-act-immediately/</id>
    <published>2020-04-26T04:00:00.000Z</published>
    <updated>2020-04-26T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;当你决定做一件事情时，你必须在72小时之内行动起来，否则你可能永远不会再做了。这是前两天从一本书上学习到的一句话，觉得很有道理，无关乎是不是三分钟热度，因为我们处在一个信息爆炸的时代，每天又在不断的被信息淹没，如果决定做一件事时不马上行动起来，很可能就会被后来的信息淹没。至
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于坚持</title>
    <link href="http://wenzhiquan.github.io/2020/04/17/2020-04-17-about-consist/"/>
    <id>http://wenzhiquan.github.io/2020/04/17/2020-04-17-about-consist/</id>
    <published>2020-04-17T04:00:00.000Z</published>
    <updated>2020-04-17T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近听到了几个定律：荷花定律，竹子定律和金蝉定律，其核心思想都是要坚持不懈，荷花在最后一天开满池塘，而前一天只有一半而已，竹子4年时间发展根系，只为之后迸发的成长，蝉在底下长久深埋，只为最后的腾飞。这些其实都很符合当今的一个说法，苦练基本功，延迟满足感，不要因为眼前一时的得
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>「2+2」 原则</title>
    <link href="http://wenzhiquan.github.io/2020/04/12/2020-04-12-2-plus-2/"/>
    <id>http://wenzhiquan.github.io/2020/04/12/2020-04-12-2-plus-2/</id>
    <published>2020-04-12T04:00:00.000Z</published>
    <updated>2020-04-12T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;当我们遇到困难需要向上寻求帮助时，可以使用【2+2】原则，一共提出四个问题：1. 期望的结果是什么；2. 当前的进展是什么；3. 遇到了什么困难；4.
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于任务优先级</title>
    <link href="http://wenzhiquan.github.io/2020/04/03/2020-04-03-mission-priority/"/>
    <id>http://wenzhiquan.github.io/2020/04/03/2020-04-03-mission-priority/</id>
    <published>2020-04-03T04:00:00.000Z</published>
    <updated>2020-04-03T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;我们都知道事情是需要分紧急程度和重要程度的，那我们应该如何对这些事情排出优先级呢？首先对于不紧急不重要的事情我们不要耗费时间去做，对于紧急不重要的事情一般我们称为琐事，要无负担的做，最好就是记录到 todo-list
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Learning By Doing</title>
    <link href="http://wenzhiquan.github.io/2020/03/29/2020-03-29-learning-by-doing/"/>
    <id>http://wenzhiquan.github.io/2020/03/29/2020-03-29-learning-by-doing/</id>
    <published>2020-03-29T04:00:00.000Z</published>
    <updated>2020-03-29T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;之前听一鸣同学说我们要 Learning By
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>双向反馈法</title>
    <link href="http://wenzhiquan.github.io/2020/03/15/2020-03-15-double-side-feedback/"/>
    <id>http://wenzhiquan.github.io/2020/03/15/2020-03-15-double-side-feedback/</id>
    <published>2020-03-15T04:00:00.000Z</published>
    <updated>2020-03-15T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;当我们需要对他人的工作做出评价的时候，最好使用双向反馈法——既要给出激励性反馈，又要给出建设性反馈，每种反馈至少三条。激励性反馈是指找出其做得好的点，给出反馈，建设性反馈即找出可以改进的点，进行反馈。双向反馈法的好处是可以帮助我们更全面的考虑，避免出现片面的评价，同时又能为
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>BBS 法则</title>
    <link href="http://wenzhiquan.github.io/2020/03/06/2020-03-06-bbs-principle/"/>
    <id>http://wenzhiquan.github.io/2020/03/06/2020-03-06-bbs-principle/</id>
    <published>2020-03-06T04:00:00.000Z</published>
    <updated>2020-03-06T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这周学习到了一个很好的方法论【BBS】，分别是 learn from the Best，Basic way 和 Stop doing list，首先我们需要制定自己的 Stop doing list，这样才能够让自己不偏离正确的方向，Basic way
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>MECE 法则</title>
    <link href="http://wenzhiquan.github.io/2020/02/11/2020-02-21-mece-principle/"/>
    <id>http://wenzhiquan.github.io/2020/02/11/2020-02-21-mece-principle/</id>
    <published>2020-02-11T04:00:00.000Z</published>
    <updated>2020-02-11T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本周学习到了一个很有意思的原则，【MECE法则】，全称是 Mutually Exclusive Collectively
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java 通配符简析</title>
    <link href="http://wenzhiquan.github.io/2019/03/02/2019-03-02-java-wildcards/"/>
    <id>http://wenzhiquan.github.io/2019/03/02/2019-03-02-java-wildcards/</id>
    <published>2019-03-02T04:00:00.000Z</published>
    <updated>2019-03-02T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“Java 通配符是一种表示未知类型的类型约束的方法。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;通配符&lt;/code&gt; 并不包含在最初的泛型设计中（起源于 Generic Java（GJ）项目），从形成 JSR 14 到发布其最终版本之间的五年多时间内完成设计过程并被添加到了泛型中。&lt;code&gt;通配符&lt;/code&gt; 在类型系统中具有重要的意义，它们为一个泛型类所指定的类型集合提供了一个有用的类型范围。Oracle 的官方解释是 Type of unknown。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://wenzhiquan.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://wenzhiquan.github.io/tags/Java/"/>
    
      <category term="通配符" scheme="http://wenzhiquan.github.io/tags/%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java Annotation 简析</title>
    <link href="http://wenzhiquan.github.io/2018/07/13/2018-07-13-java-annotation/"/>
    <id>http://wenzhiquan.github.io/2018/07/13/2018-07-13-java-annotation/</id>
    <published>2018-07-13T04:00:00.000Z</published>
    <updated>2018-07-13T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“Java Annotation 是 JDK5.0 引入的一种注释机制, 用于为 Java 代码提供元数据。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Annotation&lt;/code&gt;，中文译名为注解，那么注解又是什么呢？简单来说，注解就是对某件事物的标记和解释，用来描述这件事物的特点和属性。举个例子，前一阵看《创造 101》，看到了一名熟悉的 &lt;code&gt;Rapper&lt;/code&gt; – Yamy，参加这个节目之后，她又被打上了 &lt;code&gt;Dancer&lt;/code&gt; 的标签。对于 Yamy 来说，&lt;code&gt;Rapper&lt;/code&gt; 和 &lt;code&gt;Dancer&lt;/code&gt; 就是对她的注解。我们通过注解，可以在一定程度上了解到被标记事物的一些属性，我们就可以用这些属性来做一些事情。比如在《中国有嘻哈》利用 &lt;code&gt;Rapper&lt;/code&gt; 标签宣传 Yamy 的说唱能力，而在《创造 101》利用 &lt;code&gt;Dancer&lt;/code&gt; 标签宣传 Yamy 的跳舞能力等。&lt;/p&gt;
&lt;p&gt;从上面的例子我们可以看出来，通过获取事物的注解，可以得到事物的属性，利用这些属性可以进行一些操作。代码也是这样，通过获取代码的注解，我们可以获得注解赋予代码的属性，利用这些属性，我们就可以在程序的生命周期中，对具有这些属性的代码进行额外的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://wenzhiquan.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://wenzhiquan.github.io/tags/Java/"/>
    
      <category term="Annotation" scheme="http://wenzhiquan.github.io/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Vim 简明教程</title>
    <link href="http://wenzhiquan.github.io/2018/06/30/2018-06-30-vim-introduction/"/>
    <id>http://wenzhiquan.github.io/2018/06/30/2018-06-30-vim-introduction/</id>
    <published>2018-06-30T04:00:00.000Z</published>
    <updated>2018-06-30T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“Vim 是一个历史悠久的，具有很多命令的功能非常强大的文本编辑器，被称为 &lt;code&gt;编辑器之神&lt;/code&gt;。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vim&lt;/a&gt; 是从 vi 发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。两派使用者经常发起 “XXX 才是最好的编辑器” 之争。&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://wenzhiquan.github.io/categories/Vim/"/>
    
    
      <category term="vim" scheme="http://wenzhiquan.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--策略模式</title>
    <link href="http://wenzhiquan.github.io/2018/06/27/2018-06-27-design-pattern-strategy/"/>
    <id>http://wenzhiquan.github.io/2018/06/27/2018-06-27-design-pattern-strategy/</id>
    <published>2018-06-27T04:00:00.000Z</published>
    <updated>2018-06-27T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。&lt;/p&gt;
&lt;p&gt;策略模式是一种对象行为型模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="http://wenzhiquan.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="http://wenzhiquan.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--观察者模式</title>
    <link href="http://wenzhiquan.github.io/2018/06/26/2018-06-26-design-pattern-observer/"/>
    <id>http://wenzhiquan.github.io/2018/06/26/2018-06-26-design-pattern-observer/</id>
    <published>2018-06-26T04:00:00.000Z</published>
    <updated>2018-06-26T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;当对象间存在一对多关系，且当一个对象被修改时，会自动通知它的依赖对象，则使用观察者模式（Observer Pattern）。观察者模式属于行为型模式。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="行为型模式" scheme="http://wenzhiquan.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="http://wenzhiquan.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--抽象工厂模式</title>
    <link href="http://wenzhiquan.github.io/2018/06/25/2018-06-25-design-pattern-abstract-factory/"/>
    <id>http://wenzhiquan.github.io/2018/06/25/2018-06-25-design-pattern-abstract-factory/</id>
    <published>2018-06-25T04:00:00.000Z</published>
    <updated>2018-06-25T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;工厂方法模式&lt;/code&gt;中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。此时工厂方法模式就无法完成需求，而抽象工厂模式可以解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="http://wenzhiquan.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://wenzhiquan.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--工厂方法模式</title>
    <link href="http://wenzhiquan.github.io/2018/06/16/2018-06-16-design-pattern-factory-method/"/>
    <id>http://wenzhiquan.github.io/2018/06/16/2018-06-16-design-pattern-factory-method/</id>
    <published>2018-06-16T04:00:00.000Z</published>
    <updated>2018-06-16T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;由于简单工厂模式每次增加新的产品时，都需要修改工厂类，违背了开闭原则，可以通过定义工厂类的父类，为每种产品都创建一个工厂，从而动态的获取子类，并且增加产品时增加工厂子类即可，不用修改工厂父类。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="http://wenzhiquan.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://wenzhiquan.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--简单工厂模式</title>
    <link href="http://wenzhiquan.github.io/2018/06/15/2018-06-15-design-pattern-simple-factory/"/>
    <id>http://wenzhiquan.github.io/2018/06/15/2018-06-15-design-pattern-simple-factory/</id>
    <published>2018-06-15T04:00:00.000Z</published>
    <updated>2018-06-15T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;简单工厂模式是最简单的设计模式之一，简单到甚至没有放到23种常用设计模式当中，可以用于设计模式的入门学习。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://wenzhiquan.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="http://wenzhiquan.github.io/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://wenzhiquan.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Thrift 简析</title>
    <link href="http://wenzhiquan.github.io/2018/05/30/2018-05-30-thrift-introduction/"/>
    <id>http://wenzhiquan.github.io/2018/05/30/2018-05-30-thrift-introduction/</id>
    <published>2018-05-30T04:00:00.000Z</published>
    <updated>2018-06-21T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Thrift 是一种可扩展、跨语言的服务开发框架，用于各个服务之间的 RPC 通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Thrift&lt;/code&gt; 最初由 &lt;code&gt;Facebook&lt;/code&gt; 于 2007 年开发，2008 年进入 &lt;code&gt;Apache&lt;/code&gt; 开源项目。Thrift 主要用于各个服务之间的 RPC 通信，是一种可扩展、跨语言的 &lt;code&gt;RPC&lt;/code&gt; 服务开发框架，其服务端和客户端可以用不同的语言来开发。只需要依照 IDL（Interface Description Language）定义一次接口，Thrift 工具就能编译生成 C++, Java, Python, PHP, Ruby, JavaScript, Node.js 等语言的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="Thrift" scheme="http://wenzhiquan.github.io/categories/Thrift/"/>
    
    
      <category term="RPC" scheme="http://wenzhiquan.github.io/tags/RPC/"/>
    
      <category term="Thrift" scheme="http://wenzhiquan.github.io/tags/Thrift/"/>
    
  </entry>
  
  <entry>
    <title>RPC 简析</title>
    <link href="http://wenzhiquan.github.io/2018/05/29/2018-05-29-rpc-introduction/"/>
    <id>http://wenzhiquan.github.io/2018/05/29/2018-05-29-rpc-introduction/</id>
    <published>2018-05-29T04:00:00.000Z</published>
    <updated>2018-05-29T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;h4 id=&quot;什么是-RPC&quot;&gt;&lt;a href=&quot;#什么是-RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是 RPC&quot;&gt;&lt;/a&gt;什么是 &lt;code&gt;RPC&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;RPC&lt;/code&gt;，全称为 &lt;code&gt;Remote Procedure Call&lt;/code&gt;，即远程过程调用，是一种进程间的通信方式。它能够实现从主机 A 调用可达地址空间中另一台主机 B 上的过程或函数，而程序员并不需要显示的编码其调用过程。也即是说对于程序员来说，这个调用过程是透明的，本地调用和远程调用所用代码基本是相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="RPC" scheme="http://wenzhiquan.github.io/categories/RPC/"/>
    
    
      <category term="RPC" scheme="http://wenzhiquan.github.io/tags/RPC/"/>
    
  </entry>
  
</feed>
