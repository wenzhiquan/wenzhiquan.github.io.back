<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温智全的博客</title>
  
  <subtitle>Wenknows&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wenzhiquan.github.io/"/>
  <updated>2021-05-15T04:00:00.000Z</updated>
  <id>http://wenzhiquan.github.io/</id>
  
  <author>
    <name>温智全</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何提升记忆水平</title>
    <link href="http://wenzhiquan.github.io/2021/05/15/2021-05-15-raise-memory-level/"/>
    <id>http://wenzhiquan.github.io/2021/05/15/2021-05-15-raise-memory-level/</id>
    <published>2021-05-15T04:00:00.000Z</published>
    <updated>2021-05-15T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;我们都知道记忆其实是大脑中神经回路的形成，分为短期记忆和长期记忆，通过重复我们可以把短期记忆变为长期记忆，艾宾浩斯遗忘曲线大家肯定也不陌生，费曼学习法是耳熟能详，今天看了一篇文章，提到了一些其他方式，感觉比较新奇，和大家分享一下：LTP
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="阅读感想" scheme="http://wenzhiquan.github.io/tags/%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收和 Golang 内存管理</title>
    <link href="http://wenzhiquan.github.io/2021/05/06/2021-05-06-go-gc-memory/"/>
    <id>http://wenzhiquan.github.io/2021/05/06/2021-05-06-go-gc-memory/</id>
    <published>2021-05-06T04:00:00.000Z</published>
    <updated>2021-05-06T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h1&gt;&lt;p&gt;陆老师今天的课程从 GC 的发展历程讲起，渐次讲解了垃圾回收的流派以及基础的垃圾回收方法，从而引出 Golang 的 GC，向我们讲述了 Golang 垃圾回收的特点与触发时机，最终为我们简述了一些编程过程中可能使用到的工具和指标，帮助我们更快的找到和分析问题。&lt;/p&gt;
&lt;h1 id=&quot;GC-基本理论&quot;&gt;&lt;a href=&quot;#GC-基本理论&quot; class=&quot;headerlink&quot; title=&quot;GC 基本理论&quot;&gt;&lt;/a&gt;GC 基本理论&lt;/h1&gt;&lt;p&gt;GC 的发展从 1959 年的 Lisp 语言就开始了，他所做的事情其实就是把需要程序员手动申请和释放内存这件事情自动化了，解放了程序员的生产力，能够用更多的精力放在业务代码上而不是去关心内存，经历了几十年的发展，GC 也变得越来越完善，功能也变得越来越强大了。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/categories/Golang/"/>
    
    
      <category term="垃圾回收" scheme="http://wenzhiquan.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang scheduler 浅析</title>
    <link href="http://wenzhiquan.github.io/2021/04/30/2021-04-30-golang-scheduler/"/>
    <id>http://wenzhiquan.github.io/2021/04/30/2021-04-30-golang-scheduler/</id>
    <published>2021-04-30T04:00:00.000Z</published>
    <updated>2021-04-30T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h1&gt;&lt;p&gt;饶老师从一个故事讲起，引出了调度器的概念和 Golang 的调度器模型，并深入的讲解了 Golang 的循环调度的实现和抢占式调度的实现，不禁令人感叹，Golang 的循环调度为我们的岁月静好负重前行。&lt;/p&gt;
&lt;h1 id=&quot;循环调度的建立&quot;&gt;&lt;a href=&quot;#循环调度的建立&quot; class=&quot;headerlink&quot; title=&quot;循环调度的建立&quot;&gt;&lt;/a&gt;循环调度的建立&lt;/h1&gt;&lt;p&gt;所谓对 goroutine 的调度，实际上就是指 Golang 程序代码按照内置的一些算法，在运行时动态的选择合适的 goroutine 放到 CPU 上去执行的过程， 其本质是通过保存和恢复 CPU 寄存器的值达到切换 goroutine 的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 并发数据结构和算法实践</title>
    <link href="http://wenzhiquan.github.io/2021/04/28/2021-04-28-concurrent-data-structure%20copy/"/>
    <id>http://wenzhiquan.github.io/2021/04/28/2021-04-28-concurrent-data-structure copy/</id>
    <published>2021-04-28T04:00:00.000Z</published>
    <updated>2021-04-28T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h1&gt;&lt;p&gt;云浩老师这门课程中，从引入 Golang 本身数据结构对多核性能使用不足的场景讲起，然后由并发安全问题讲起，阐述了解决并发问题的通用方案，并基于此，提出了有序链表的并行化方案，由猜想到验证一步一步引导我们实现一个在多核场景下 scalable 的数据结构，由浅入深，令人印象深刻。&lt;/p&gt;
&lt;h1 id=&quot;并发安全问题&quot;&gt;&lt;a href=&quot;#并发安全问题&quot; class=&quot;headerlink&quot; title=&quot;并发安全问题&quot;&gt;&lt;/a&gt;并发安全问题&lt;/h1&gt;&lt;p&gt;并发安全问题，表现为对一个变量发生更改的同时有另一个线程对同一个变量进行了读写，导致产生了不可预知的行为，也叫 data race&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 的强人锁难</title>
    <link href="http://wenzhiquan.github.io/2021/04/24/2021-04-24-golang-lock/"/>
    <id>http://wenzhiquan.github.io/2021/04/24/2021-04-24-golang-lock/</id>
    <published>2021-04-24T04:00:00.000Z</published>
    <updated>2021-04-24T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h1&gt;&lt;p&gt;冯敏老师从一个不加锁并发修改导致出现问题的例子讲起，用最佳实践匹配我们工作中的实际场景，提出一些避免踩坑的建议，从而引出锁的进化和原理。&lt;/p&gt;
&lt;h1 id=&quot;最佳实践&quot;&gt;&lt;a href=&quot;#最佳实践&quot; class=&quot;headerlink&quot; title=&quot;最佳实践&quot;&gt;&lt;/a&gt;最佳实践&lt;/h1&gt;&lt;h2 id=&quot;减少持有时间&quot;&gt;&lt;a href=&quot;#减少持有时间&quot; class=&quot;headerlink&quot; title=&quot;减少持有时间&quot;&gt;&lt;/a&gt;减少持有时间&lt;/h2&gt;&lt;h3 id=&quot;缩小临界区，注意-defer-的使用&quot;&gt;&lt;a href=&quot;#缩小临界区，注意-defer-的使用&quot; class=&quot;headerlink&quot; title=&quot;缩小临界区，注意 defer 的使用&quot;&gt;&lt;/a&gt;缩小临界区，注意 defer 的使用&lt;/h3&gt;&lt;p&gt;通过缩小临界区的方式，可以避免在加锁和解锁之间，由于有较为耗时的代码，导致锁持有时间过长，从而造成性能问题，例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; Users = &lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;user&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;password&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; mu sync.Mutex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CheckUser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, password &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mu.Lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; mu.Unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    realPwd, exist: = Users[name]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; exist &amp;amp; realPwd == password&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;乍看之下这段代码是没有什么问题的，但是如果代码像下面这样&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Func SomeFunc() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// do sth&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mu.Lock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    defer mu.Unlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// long code&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;params&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 defer 之后的代码特别耗时，那这个 mu 锁的时间就会非常长了，会拖慢整个程序的速度。&lt;br&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>苦练基本功，延迟满足感</title>
    <link href="http://wenzhiquan.github.io/2021/04/22/2021-04-22-basics-delay-satisfication/"/>
    <id>http://wenzhiquan.github.io/2021/04/22/2021-04-22-basics-delay-satisfication/</id>
    <published>2021-04-22T04:00:00.000Z</published>
    <updated>2021-04-22T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;所谓基本功，即为我们日常工作中的专业技能，比如程序员的编码能力、系统设计能力，产品经理的文档能力、产品设计能力，销售的推销能力等，为什么说要苦练呢？因为练习基本功是一个长期持续，可能伴随着重复和枯燥的过程，热血上头坚持几天不是什么难事，难就难在长期坚持，不断缓慢的提升自己，
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Golang On The Toilet</title>
    <link href="http://wenzhiquan.github.io/2021/04/18/2021-04-18-gott/"/>
    <id>http://wenzhiquan.github.io/2021/04/18/2021-04-18-gott/</id>
    <published>2021-04-18T04:00:00.000Z</published>
    <updated>2021-04-18T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h1&gt;&lt;p&gt;本文提供了一些 Golang 工程项目的最佳实践，分别从可读性、健壮性和效率三个方面进行描述。&lt;/p&gt;
&lt;h1 id=&quot;Readable&quot;&gt;&lt;a href=&quot;#Readable&quot; class=&quot;headerlink&quot; title=&quot;Readable&quot;&gt;&lt;/a&gt;Readable&lt;/h1&gt;&lt;p&gt;可读性对于机器来说其实没有什么区别，但是对于作为开发者的每一个&lt;code&gt;人&lt;/code&gt;来说，可读性就显得极其重要了。对于个人开发者来说，一个人不可能记住他写的每一行代码，很多时候我们自己写的代码，经过两三个月之后，我们基本上就会忘记当初写的逻辑，高可读的代码可以让我们更加轻易地进行阅读回忆；而对于协同开发来说，代码的可读性直接决定了多人合作开发的效率，高可读的代码可以让我们协作开发的效率得到巨大的提升，那么常用的代码中有哪些方式可以提升代码的可读性呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Slice、Map 和 Channel 那些事儿</title>
    <link href="http://wenzhiquan.github.io/2021/04/16/2021-04-16-slice-map-channel%20copy/"/>
    <id>http://wenzhiquan.github.io/2021/04/16/2021-04-16-slice-map-channel copy/</id>
    <published>2021-04-16T04:00:00.000Z</published>
    <updated>2021-04-16T04:00:00.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h1&gt;&lt;p&gt;我是加入字节之后才开始学习使用 Golang 的，在学习和应用这门语言的过程中，踩过很多坑，但是踩坑的同时也学习到了很多有用的知识和技巧。通过不断沉淀这些知识和技巧，我们能够更叫高效和保证质量的完成业务代码，避免造成不必要的损失。&lt;/p&gt;
&lt;p&gt;建议大家都先去看一下 &lt;a href=&quot;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;50 Shades of Go&lt;/a&gt;，里面涉及了 Golang 开发初期最容易踩得 50 个坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://wenzhiquan.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>方法论的作用</title>
    <link href="http://wenzhiquan.github.io/2021/03/30/2021-03-30-about-methodology/"/>
    <id>http://wenzhiquan.github.io/2021/03/30/2021-03-30-about-methodology/</id>
    <published>2021-03-30T04:00:00.000Z</published>
    <updated>2021-03-30T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;今天周年庆的仪式上，一鸣提到了他觉得方法论可以说是没有什么作用，抽象相当于在思维上加杠杆，是一种思考上的偷懒，并列举了一个“赋能、闭环”的例子来论证这个事。我部分赞同他的观点，但我还是觉得方法论是有其意义和使用场景的，在我看来，方法论其实是一种对日常工作工程中的经验模型的一
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>再看 whwhorere 方法论</title>
    <link href="http://wenzhiquan.github.io/2021/03/18/2021-03-18-whwhorere/"/>
    <id>http://wenzhiquan.github.io/2021/03/18/2021-03-18-whwhorere/</id>
    <published>2021-03-18T04:00:00.000Z</published>
    <updated>2021-03-18T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Whwhorere 是美团提出的一个适用于产品规划和思考的方法论，其构成为 Why, What, Object, Resource, Roadmap, Evaluation，其实和我们经常提到的 5W1H
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于权责利的思考</title>
    <link href="http://wenzhiquan.github.io/2021/03/12/2021-03-12-authority-responsibility-benefit/"/>
    <id>http://wenzhiquan.github.io/2021/03/12/2021-03-12-authority-responsibility-benefit/</id>
    <published>2021-03-12T04:00:00.000Z</published>
    <updated>2021-03-12T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;今天看到了一篇文章，讲的是一个团队指定了 A 作为 B 的上级，但是 A 却没有批复 B 的申请，给 B 打绩效的权利，B 的绩效好坏也不影响 A，久而久之 B 不再听从 A 的安排，A 也不去管 B，导致 AB
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="阅读感想" scheme="http://wenzhiquan.github.io/tags/%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>关于天赋和习惯的思考</title>
    <link href="http://wenzhiquan.github.io/2021/02/28/2021-02-28-talent-and-habit/"/>
    <id>http://wenzhiquan.github.io/2021/02/28/2021-02-28-talent-and-habit/</id>
    <published>2021-02-28T04:00:00.000Z</published>
    <updated>2021-02-28T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这周看到一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/VIGupHjhN1JOnTqQbk8QfQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不错的文章&lt;/a&gt;，
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="阅读感想" scheme="http://wenzhiquan.github.io/tags/%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>关于中观层面的思考</title>
    <link href="http://wenzhiquan.github.io/2021/02/19/2021-02-19-meso-consideration/"/>
    <id>http://wenzhiquan.github.io/2021/02/19/2021-02-19-meso-consideration/</id>
    <published>2021-02-19T04:00:00.000Z</published>
    <updated>2021-02-19T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;昨天和朋友讨论了一下关于工作总结应该如何去做的问题，他提出了一个观点我觉得十分正确，就是在总结中我们需要增加我们对于中观层面的思考，而不是仅仅罗列我们做了那些事情和达到了哪些效果。这让我想起了一个之前听到的一个做事情的方法论，叫做「以终为始」，在我们分析问题的时候应该从想要
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>如何更加完善的考虑和完成需求</title>
    <link href="http://wenzhiquan.github.io/2021/02/09/2021-02-09-how-to-consider-more-perfect/"/>
    <id>http://wenzhiquan.github.io/2021/02/09/2021-02-09-how-to-consider-more-perfect/</id>
    <published>2021-02-09T04:00:00.000Z</published>
    <updated>2021-02-09T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;首先，我们需要明确的一点是，用户也无法清晰的知道自己的需求是什么。所以我们在跟用户讨论需求的时候，不要去问用户想要什么功能，否则往往会陷入细节却无法得出真正想要的结果，更好的方式是去引导用户讲述自己的使用场景，以及为什么会有这样的使用场景，自己的痛点是什么。收集过后，使用
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>如何看待看似不公正的待遇</title>
    <link href="http://wenzhiquan.github.io/2021/01/28/2021-01-28-how-to-deal-with-unfair-treat/"/>
    <id>http://wenzhiquan.github.io/2021/01/28/2021-01-28-how-to-deal-with-unfair-treat/</id>
    <published>2021-01-28T04:00:00.000Z</published>
    <updated>2021-01-28T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;有时候会听到一些同学的吐槽，说自己遭受了上级的不公正待遇，把更好的机会给了另一位同学而不是自己，导致自己的绩效不出彩，甚至会心生怨怼。其实我们可以设身处地的从两个方面来考虑这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让自己站在上级的角度，思考一下为什么上级会把这个机会交给另一位同
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>如何更好的处理你的版本 tag</title>
    <link href="http://wenzhiquan.github.io/2021/01/27/2021-01-27-how-to-deal-with-tag/"/>
    <id>http://wenzhiquan.github.io/2021/01/27/2021-01-27-how-to-deal-with-tag/</id>
    <published>2021-01-27T04:00:00.000Z</published>
    <updated>2021-01-27T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;今天在发布上线的时候，CI 突然报错没有通过编译，打开一看，惊了，之前依赖的公司内部的一个组件库的 tag 删除了😂，oncall 问了原因，告知是有两个连续的版本 1.0.2 和 1.0.3
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>关于系统设计抽象一层的思考</title>
    <link href="http://wenzhiquan.github.io/2021/01/11/2021-01-11-about-persevere/"/>
    <id>http://wenzhiquan.github.io/2021/01/11/2021-01-11-about-persevere/</id>
    <published>2021-01-11T04:00:00.000Z</published>
    <updated>2021-01-11T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;从我开始用「不背单词」APP 背单词和「多邻国」APP 学日语已经 50 天了，以前都说 21
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>关于系统设计抽象一层的思考</title>
    <link href="http://wenzhiquan.github.io/2020/12/14/2020-12-14-abstract-thinking-of-system-design/"/>
    <id>http://wenzhiquan.github.io/2020/12/14/2020-12-14-abstract-thinking-of-system-design/</id>
    <published>2020-12-14T04:00:00.000Z</published>
    <updated>2020-12-14T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;平常在设计系统时，会基于现有的条件进行系统架构的设计，满足当前用户的需求，以最小的代价完成系统设计和实现。这样的设计在无法完全确定当前业务能否“活下来”的情况下是比较适用的，因为成本较低，可以快速试错，但是带来的缺点是总以最小代价来进行设计，可能会导致设计能力的原地踏步。因
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="个人思考" scheme="http://wenzhiquan.github.io/tags/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>one on one 时需要注意的点（对同级或下级）</title>
    <link href="http://wenzhiquan.github.io/2020/12/06/2020-12-06-how-to-one-on-one/"/>
    <id>http://wenzhiquan.github.io/2020/12/06/2020-12-06-how-to-one-on-one/</id>
    <published>2020-12-06T04:00:00.000Z</published>
    <updated>2020-12-06T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;最近学习了一个与人 one on one
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="方法论" scheme="http://wenzhiquan.github.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>重要的 15.87%</title>
    <link href="http://wenzhiquan.github.io/2020/11/30/2020-11-30-important-15.87%25/"/>
    <id>http://wenzhiquan.github.io/2020/11/30/2020-11-30-important-15.87%/</id>
    <published>2020-11-30T04:00:00.000Z</published>
    <updated>2020-11-30T04:00:00.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;今天看到万维钢的一篇文章，讲到我们学习的三个区域：舒适区，学习区和恐慌区，在学习区我们可以达到心流状态，让我们的工作挑战和技能形成平衡，这也就需要我们要在已有的知识技能的基础上增加“意外”，也就是学习新的内容，这个新内容比例经过研究表明是
        
      
    
    </summary>
    
      <category term="思考与感想" scheme="http://wenzhiquan.github.io/categories/%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
      <category term="阅读感想" scheme="http://wenzhiquan.github.io/tags/%E9%98%85%E8%AF%BB%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
</feed>
